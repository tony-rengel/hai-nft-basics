{"version":3,"file":"transactions.cjs.production.min.js","sources":["../src/constants.ts","../../../node_modules/regenerator-runtime/runtime.js","../src/keys.ts","../src/clarity/clarityValue.ts","../src/errors.ts","../src/postcondition.ts","../src/payload.ts","../src/clarity/types/principalCV.ts","../src/types.ts","../src/clarity/types/booleanCV.ts","../src/clarity/types/intCV.ts","../src/clarity/types/bufferCV.ts","../src/clarity/types/optionalCV.ts","../src/clarity/types/responseCV.ts","../src/clarity/types/listCV.ts","../src/clarity/types/tupleCV.ts","../src/clarity/types/stringCV.ts","../src/clarity/serialize.ts","../src/bufferReader.ts","../src/clarity/deserialize.ts","../src/utils.ts","../src/authorization.ts","../src/contract-abi.ts","../src/transaction.ts","../src/signer.ts","../src/builders.ts"],"sourcesContent":["/**\n * Unsigned 32-bit integer\n */\nenum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\nconst DEFAULT_CHAIN_ID = ChainID.Mainnet;\nconst MAX_STRING_LENGTH_BYTES = 128;\nconst CLARITY_INT_SIZE = 128;\nconst COINBASE_BUFFER_LENGTH_BYTES = 32;\nconst RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nconst COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nconst UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nconst MEMO_MAX_LENGTH_BYTES = 34;\nconst DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';\n\nenum StacksMessageType {\n  Address,\n  Principal,\n  LengthPrefixedString,\n  MemoString,\n  AssetInfo,\n  PostCondition,\n  PublicKey,\n  LengthPrefixedList,\n  Payload,\n  MessageSignature,\n  TransactionAuthField,\n}\n\nenum PayloadType {\n  TokenTransfer = 0x00,\n  SmartContract = 0x01,\n  ContractCall = 0x02,\n  PoisonMicroblock = 0x03,\n  Coinbase = 0x04,\n}\n\nenum AnchorMode {\n  OnChainOnly = 0x01,\n  OffChainOnly = 0x02,\n  Any = 0x03,\n}\n\nenum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\nconst DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\nenum PostConditionMode {\n  Allow = 0x01,\n  Deny = 0x02,\n}\n\nenum PostConditionType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum AuthType {\n  Standard = 0x04,\n  Sponsored = 0x05,\n}\n\nenum AddressHashMode {\n  // serialization modes for public keys to addresses.\n  // We support four different modes due to legacy compatibility with Stacks v1 addresses:\n  /** SingleSigHashMode - hash160(public-key), same as bitcoin's p2pkh */\n  SerializeP2PKH = 0x00,\n  /** MultiSigHashMode - hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SH = 0x01,\n  /** SingleSigHashMode - hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */\n  SerializeP2WPKH = 0x02,\n  /** MultiSigHashMode - hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSH = 0x03,\n}\n\ntype SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;\ntype MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;\n\nenum AddressVersion {\n  MainnetSingleSig = 22,\n  MainnetMultiSig = 20,\n  TestnetSingleSig = 26,\n  TestnetMultiSig = 21,\n}\n\nenum PubKeyEncoding {\n  Compressed = 0x00,\n  Uncompressed = 0x01,\n}\n\nenum FungibleConditionCode {\n  Equal = 0x01,\n  Greater = 0x02,\n  GreaterEqual = 0x03,\n  Less = 0x04,\n  LessEqual = 0x05,\n}\n\nenum NonFungibleConditionCode {\n  DoesNotOwn = 0x10,\n  Owns = 0x11,\n}\n\nenum PostConditionPrincipalID {\n  Origin = 0x01,\n  Standard = 0x02,\n  Contract = 0x03,\n}\n\nenum AssetType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum TxRejectedReason {\n  Serialization = 'Serialization',\n  Deserialization = 'Deserialization',\n  SignatureValidation = 'SignatureValidation',\n  FeeTooLow = 'FeeTooLow',\n  BadNonce = 'BadNonce',\n  NotEnoughFunds = 'NotEnoughFunds',\n  NoSuchContract = 'NoSuchContract',\n  NoSuchPublicFunction = 'NoSuchPublicFunction',\n  BadFunctionArgument = 'BadFunctionArgument',\n  ContractAlreadyExists = 'ContractAlreadyExists',\n  PoisonMicroblocksDoNotConflict = 'PoisonMicroblocksDoNotConflict',\n  PoisonMicroblockHasUnknownPubKeyHash = 'PoisonMicroblockHasUnknownPubKeyHash',\n  PoisonMicroblockIsInvalid = 'PoisonMicroblockIsInvalid',\n  BadAddressVersionByte = 'BadAddressVersionByte',\n  NoCoinbaseViaMempool = 'NoCoinbaseViaMempool',\n  ServerFailureNoSuchChainTip = 'ServerFailureNoSuchChainTip',\n  ServerFailureDatabase = 'ServerFailureDatabase',\n  ServerFailureOther = 'ServerFailureOther',\n}\n\nexport {\n  MAX_STRING_LENGTH_BYTES,\n  CLARITY_INT_SIZE,\n  COINBASE_BUFFER_LENGTH_BYTES,\n  DEFAULT_CHAIN_ID,\n  DEFAULT_TRANSACTION_VERSION,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  DEFAULT_CORE_NODE_API_URL,\n  ChainID,\n  StacksMessageType,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  PostConditionMode,\n  PostConditionType,\n  PostConditionPrincipalID,\n  AuthType,\n  AddressHashMode,\n  SingleSigHashMode,\n  MultiSigHashMode,\n  AddressVersion,\n  PubKeyEncoding,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  AssetType,\n  TxRejectedReason,\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import {\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  StacksMessageType,\n  AddressHashMode,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  BufferArray,\n  leftPadHexToLength,\n  intToHexString,\n  randomBytes,\n  hash160,\n  hashP2PKH,\n  hexStringToInt,\n} from './utils';\n\nimport { ec as EC } from 'elliptic';\n\nimport { MessageSignature, createMessageSignature } from './authorization';\nimport { BufferReader } from './bufferReader';\nimport { AddressVersion } from './constants';\nimport { c32address } from 'c32check';\nimport { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types';\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignature(message: string, messageSignature: MessageSignature) {\n  const ec = new EC('secp256k1');\n  const messageBN = ec.keyFromPrivate(message, 'hex').getPrivate().toString(10);\n\n  const parsedSignature = parseRecoverableSignature(messageSignature.data);\n\n  const publicKey = ec.recoverPubKey(\n    messageBN,\n    parsedSignature,\n    parsedSignature.recoveryParam,\n    'hex'\n  ) as { encodeCompressed: (enc: string) => string };\n\n  return publicKey.encodeCompressed('hex');\n}\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const ec = new EC('secp256k1');\n  const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');\n  const pubKey = keyPair.getPublic(privKey.compressed, 'hex');\n  return createStacksPublicKey(pubKey);\n}\n\nexport function compressPublicKey(publicKey: string | Buffer): StacksPublicKey {\n  const ec = new EC('secp256k1');\n  const key = ec.keyFromPublic(publicKey);\n  const pubKey = key.getPublic(true, 'hex');\n  return createStacksPublicKey(pubKey);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  data: Buffer;\n  compressed: boolean;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;\n  let compressed: boolean;\n  if (data.length === 33) {\n    if (data[data.length - 1] !== 1) {\n      throw new Error(\n        'Improperly formatted private-key. 33 byte length usually ' +\n          'indicates compressed key, but last byte must be == 0x01'\n      );\n    }\n    compressed = true;\n  } else if (data.length === 32) {\n    compressed = false;\n  } else {\n    throw new Error(\n      `Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`\n    );\n  }\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(entropy?: Buffer): StacksPrivateKey {\n  const ec = new EC('secp256k1');\n  const options = { entropy: entropy || randomBytes(32) };\n  const keyPair = ec.genKeyPair(options);\n  const privateKey = keyPair.getPrivate().toString('hex', 32);\n  return createStacksPrivateKey(privateKey);\n}\n\nexport function signWithKey(privateKey: StacksPrivateKey, input: string): MessageSignature {\n  const ec = new EC('secp256k1');\n  const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');\n  const signature = key.sign(input, 'hex', { canonical: true });\n  const coordinateValueBytes = 32;\n  const r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);\n  const s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);\n  if (signature.recoveryParam === undefined || signature.recoveryParam === null) {\n    throw new Error('\"signature.recoveryParam\" is not set');\n  }\n  const recoveryParam = intToHexString(signature.recoveryParam, 1);\n  const recoverableSignatureString = recoveryParam + r + s;\n  return createMessageSignature(recoverableSignatureString);\n}\n\nexport function getSignatureRecoveryParam(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  return hexStringToInt(recoveryParamHex);\n}\n\nexport function parseRecoverableSignature(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  const r = signature.substr(2, coordinateValueBytes * 2);\n  const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);\n  return {\n    recoveryParam: hexStringToInt(recoveryParamHex),\n    r,\n    s,\n  };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n","import {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { CLARITY_INT_SIZE } from '../constants';\n\n/**\n * Type IDs corresponding to each of the Clarity value types as described here:\n * {@link https://github.com/blockstack/blockstack-core/blob/sip/sip-005/sip/sip-005-blocks-and-transactions.md#clarity-value-representation}\n */\nexport enum ClarityType {\n  Int = 0x00,\n  UInt = 0x01,\n  Buffer = 0x02,\n  BoolTrue = 0x03,\n  BoolFalse = 0x04,\n  PrincipalStandard = 0x05,\n  PrincipalContract = 0x06,\n  ResponseOk = 0x07,\n  ResponseErr = 0x08,\n  OptionalNone = 0x09,\n  OptionalSome = 0x0a,\n  List = 0x0b,\n  Tuple = 0x0c,\n  StringASCII = 0x0d,\n  StringUTF8 = 0x0e,\n}\n\nexport type ClarityValue =\n  | BooleanCV\n  | OptionalCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.fromTwos(CLARITY_INT_SIZE).toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\nexport function cvToValue(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n      return val.value.fromTwos(CLARITY_INT_SIZE).toNumber();\n    case ClarityType.UInt:\n      return val.value.toNumber();\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${getCVTypeString(val.list[0])})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}\n","export class StacksTransactionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SerializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class DeserializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class NotImplementedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SigningError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nexport class VerificationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n","import {\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  AssetInfo,\n  serializeAssetInfo,\n  deserializeAssetInfo,\n  PostConditionPrincipal,\n  serializePrincipal,\n  deserializePrincipal,\n  parseAssetInfoString,\n  parsePrincipalString,\n} from './types';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity';\nimport { DeserializationError } from './errors';\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: BigNum;\n}\n\nexport function createSTXPostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.STX,\n    principal,\n    conditionCode,\n    amount,\n  };\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: BigNum;\n  readonly assetInfo: AssetInfo;\n}\n\nexport function createFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.Fungible,\n    principal,\n    conditionCode,\n    amount,\n    assetInfo,\n  };\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function createNonFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.NonFungible,\n    principal,\n    conditionCode,\n    assetInfo,\n    assetName,\n  };\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bufferArray.push(postCondition.amount.toArrayLike(Buffer, 'be', 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePostCondition(bufferReader: BufferReader): PostCondition {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bufferReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n","import { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  Address,\n  MemoString,\n  createAddress,\n  createMemoString,\n  LengthPrefixedString,\n  createLPString,\n  serializeStacksMessage,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  codeBodyString,\n} from './types';\n\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity/';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: BigNum;\n  readonly memo: MemoString;\n}\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: BigNum,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount,\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString\n): SmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBuffer: Buffer;\n}\n\nexport function createCoinbasePayload(coinbaseBuffer: Buffer): CoinbasePayload {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\n\nexport function serializePayload(payload: Payload): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(payload.amount.toArrayLike(Buffer, 'be', 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePayload(bufferReader: BufferReader): Payload {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader) as PrincipalCV;\n      const amount = new BigNum(bufferReader.readBuffer(8));\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}\n","import {\n  Address,\n  LengthPrefixedString,\n  createAddress,\n  createLPString,\n  addressToString,\n} from '../../types';\nimport { ClarityType } from '../clarityValue';\n\ntype PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;\n\ninterface StandardPrincipalCV {\n  readonly type: ClarityType.PrincipalStandard;\n  readonly address: Address;\n}\n\ninterface ContractPrincipalCV {\n  readonly type: ClarityType.PrincipalContract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nfunction principalToString(principal: PrincipalCV): string {\n  if (principal.type === ClarityType.PrincipalStandard) {\n    return addressToString(principal.address);\n  } else if (principal.type === ClarityType.PrincipalContract) {\n    const address = addressToString(principal.address);\n    return `${address}.${principal.contractName.content}`;\n  } else {\n    throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n  }\n}\n\nfunction principalCV(principal: string): PrincipalCV {\n  if (principal.includes('.')) {\n    const [address, contractName] = principal.split('.');\n    return contractPrincipalCV(address, contractName);\n  } else {\n    return standardPrincipalCV(principal);\n  }\n}\n\nfunction standardPrincipalCV(addressString: string): StandardPrincipalCV {\n  const addr = createAddress(addressString);\n  return { type: ClarityType.PrincipalStandard, address: addr };\n}\n\nfunction standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV {\n  return { type: ClarityType.PrincipalStandard, address };\n}\n\nfunction contractPrincipalCV(addressString: string, contractName: string): ContractPrincipalCV {\n  const addr = createAddress(addressString);\n  const lengthPrefixedContractName = createLPString(contractName);\n  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\n\nfunction contractPrincipalCVFromAddress(\n  address: Address,\n  contractName: LengthPrefixedString\n): ContractPrincipalCV {\n  if (Buffer.byteLength(contractName.content) >= 128) {\n    throw new Error('Contract name must be less than 128 bytes');\n  }\n  return { type: ClarityType.PrincipalContract, address, contractName };\n}\n\nfunction contractPrincipalCVFromStandard(\n  sp: StandardPrincipalCV,\n  contractName: string\n): ContractPrincipalCV {\n  const lengthPrefixedContractName = createLPString(contractName);\n  return {\n    type: ClarityType.PrincipalContract,\n    address: sp.address,\n    contractName: lengthPrefixedContractName,\n  };\n}\n\nexport {\n  PrincipalCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  principalCV,\n  principalToString,\n  standardPrincipalCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCV,\n  contractPrincipalCVFromAddress,\n  contractPrincipalCVFromStandard,\n};\n","import {\n  MAX_STRING_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  intToHexString,\n  hexStringToInt,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n} from './utils';\n\nimport { c32addressDecode, c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport { PostCondition, serializePostCondition, deserializePostCondition } from './postcondition';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  MessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './authorization';\n\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    default:\n      throw Error(\n        `Not yet implemented: address construction using public keys for hash mode: ${hashMode}`\n      );\n  }\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\n/**\n * Parse a fully qualified string that identifies the token type.\n * @param id - String in the format `{address}.{contractName}::{assetName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token\"\n */\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n","import { ClarityType } from '../clarityValue';\n\ntype BooleanCV = TrueCV | FalseCV;\n\ninterface TrueCV {\n  type: ClarityType.BoolTrue;\n}\n\ninterface FalseCV {\n  type: ClarityType.BoolFalse;\n}\n\nconst trueCV = (): BooleanCV => ({ type: ClarityType.BoolTrue });\nconst falseCV = (): BooleanCV => ({ type: ClarityType.BoolFalse });\n\nexport { BooleanCV, TrueCV, FalseCV, trueCV, falseCV };\n","import BigNum from 'bn.js';\nimport { CLARITY_INT_SIZE } from '../../constants';\nimport { ClarityType } from '../clarityValue';\n\ninterface IntCV {\n  readonly type: ClarityType.Int;\n  readonly value: BigNum;\n}\n\nconst intCV = (value: number | string | Buffer): IntCV => {\n  const bn = new BigNum(value);\n  const twos = bn.toTwos(CLARITY_INT_SIZE);\n\n  if (twos.bitLength() > CLARITY_INT_SIZE) {\n    throw new Error('Cannot construct clarity integer from value greater than INT_SIZE bits');\n  }\n\n  return { type: ClarityType.Int, value: twos };\n};\n\ninterface UIntCV {\n  readonly type: ClarityType.UInt;\n  readonly value: BigNum;\n}\n\nconst uintCV = (value: number | string | Buffer): UIntCV => {\n  const bn = new BigNum(value);\n  const twos = bn.toTwos(CLARITY_INT_SIZE);\n\n  if (twos.isNeg()) {\n    throw new Error('Cannot construct unsigned clarity integer from negative value');\n  } else if (twos.bitLength() > CLARITY_INT_SIZE) {\n    throw new Error('Cannot construct unsigned clarity integer from value greater than 128 bits');\n  }\n\n  return { type: ClarityType.UInt, value: twos };\n};\n\nexport { IntCV, UIntCV, intCV, uintCV };\n","import { ClarityType } from '../clarityValue';\n\ninterface BufferCV {\n  readonly type: ClarityType.Buffer;\n  readonly buffer: Buffer;\n}\n\nconst bufferCV = (buffer: Buffer): BufferCV => {\n  if (buffer.length > 1000000) {\n    throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n  }\n\n  return { type: ClarityType.Buffer, buffer };\n};\n\nconst bufferCVFromString = (str: string): BufferCV => bufferCV(Buffer.from(str));\n\nexport { BufferCV, bufferCV, bufferCVFromString };\n","import { ClarityType, ClarityValue } from '../clarityValue';\n\ntype OptionalCV = NoneCV | SomeCV;\n\ninterface NoneCV {\n  readonly type: ClarityType.OptionalNone;\n}\n\ninterface SomeCV {\n  readonly type: ClarityType.OptionalSome;\n  readonly value: ClarityValue;\n}\n\nconst noneCV = (): OptionalCV => ({ type: ClarityType.OptionalNone });\nconst someCV = (value: ClarityValue): OptionalCV => ({ type: ClarityType.OptionalSome, value });\nconst optionalCVOf = (value?: ClarityValue): OptionalCV => {\n  if (value) {\n    return someCV(value);\n  } else {\n    return noneCV();\n  }\n};\n\nexport { OptionalCV, NoneCV, SomeCV, noneCV, someCV, optionalCVOf };\n","import { ClarityType, ClarityValue } from '../clarityValue';\n\ntype ResponseCV = ResponseErrorCV | ResponseOkCV;\n\ninterface ResponseErrorCV {\n  readonly type: ClarityType.ResponseErr;\n  readonly value: ClarityValue;\n}\n\ninterface ResponseOkCV {\n  readonly type: ClarityType.ResponseOk;\n  readonly value: ClarityValue;\n}\n\nfunction responseErrorCV(value: ClarityValue): ResponseErrorCV {\n  return { type: ClarityType.ResponseErr, value };\n}\n\nfunction responseOkCV(value: ClarityValue): ResponseOkCV {\n  return { type: ClarityType.ResponseOk, value };\n}\n\nexport { ResponseCV, ResponseErrorCV, ResponseOkCV, responseErrorCV, responseOkCV };\n","import { ClarityValue, ClarityType } from '../clarityValue';\n\ninterface ListCV {\n  type: ClarityType.List;\n  list: ClarityValue[];\n}\n\nfunction listCV<T extends ClarityValue>(values: T[]): ListCV {\n  return { type: ClarityType.List, list: values };\n}\n\nexport { ListCV, listCV };\n","import { ClarityType, ClarityValue } from '../clarityValue';\nimport { isClarityName } from '../../utils';\n\ntype TupleData = { [key: string]: ClarityValue };\n\ninterface TupleCV {\n  type: ClarityType.Tuple;\n  data: TupleData;\n}\n\nfunction tupleCV(data: TupleData): TupleCV {\n  for (const key in data) {\n    if (!isClarityName(key)) {\n      throw new Error(`\"${key}\" is not a valid Clarity name`);\n    }\n  }\n\n  return { type: ClarityType.Tuple, data };\n}\n\nexport { TupleCV, tupleCV };\n","import { ClarityType } from '../clarityValue';\n\ninterface StringAsciiCV {\n  readonly type: ClarityType.StringASCII;\n  readonly data: string;\n}\n\ninterface StringUtf8CV {\n  readonly type: ClarityType.StringUTF8;\n  readonly data: string;\n}\n\nconst stringAsciiCV = (data: string): StringAsciiCV => {\n  return { type: ClarityType.StringASCII, data };\n};\n\nconst stringUtf8CV = (data: string): StringUtf8CV => {\n  return { type: ClarityType.StringUTF8, data };\n};\n\nconst stringCV = (data: string, encoding: 'ascii' | 'utf8'): StringAsciiCV | StringUtf8CV => {\n  switch (encoding) {\n    case 'ascii':\n      return stringAsciiCV(data);\n    case 'utf8':\n      return stringAsciiCV(data);\n  }\n};\n\nexport { StringAsciiCV, StringUtf8CV, stringAsciiCV, stringUtf8CV, stringCV };\n","import { serializeAddress, serializeLPString, createLPString } from '../types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityType,\n  ClarityValue,\n} from '.';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\n\nfunction bufferWithTypeID(typeId: ClarityType, buffer: Buffer): Buffer {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Buffer {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Buffer {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Buffer {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv: IntCV | UIntCV): Buffer {\n  const buffer = cv.value.toArrayLike(Buffer, 'be', 16);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Buffer {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Buffer {\n  return bufferWithTypeID(\n    cv.type,\n    Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)])\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const buffers = new BufferArray();\n\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n\n  buffers.push(len);\n  buffers.push(str);\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\nexport function serializeCV(value: ClarityValue): Buffer {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n","import { SmartBuffer, SmartBufferOptions } from 'smart-buffer';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue }\n): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\nexport class BufferReader {\n  smartBuffer: SmartBuffer;\n\n  static fromBuffer(buffer: Buffer): BufferReader {\n    return new BufferReader({ buff: buffer });\n  }\n\n  constructor(options?: SmartBufferOptions | Buffer) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({ buff: options });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  readBuffer(length: number): Buffer {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset?: number): number {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8(): number {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE(): number {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE(): bigint {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg?: number | BufferEncoding, encoding?: BufferEncoding): string {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset(): number {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val: number) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer(): Buffer {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.smartBuffer.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n}\n","import {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\n\nexport default function deserializeCV(buffer: BufferReader | Buffer): ClarityValue {\n  const bufferReader = Buffer.isBuffer(buffer) ? new BufferReader(buffer) : buffer;\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16));\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16));\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength));\n\n    case ClarityType.BoolTrue:\n      return trueCV();\n\n    case ClarityType.BoolFalse:\n      return falseCV();\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress);\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName);\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader));\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader));\n\n    case ClarityType.OptionalNone:\n      return noneCV();\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader));\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n      return listCV(listContents);\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n      return tupleCV(tupleContents);\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr);\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str);\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.'\n      );\n  }\n}\n","import { sha256, sha512 } from 'sha.js';\nimport { ClarityValue, serializeCV } from './clarity';\nimport RIPEMD160 from 'ripemd160-min';\nimport randombytes from 'randombytes';\nimport { deserializeCV } from './clarity';\nimport fetch from 'cross-fetch';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash/cloneDeep';\n\nexport { randombytes as randomBytes };\n\nexport class BufferArray {\n  _value: Buffer[] = [];\n  get value() {\n    return this._value;\n  }\n  appendHexString(hexString: string) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer: Buffer) {\n    return this._value.push(buffer);\n  }\n  appendByte(octet: number) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer(): Buffer {\n    return Buffer.concat(this.value);\n  }\n}\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const intToHexString = (integer: number, lengthBytes = 8): string =>\n  integer.toString(16).padStart(lengthBytes * 2, '0');\n\nexport const hexStringToInt = (hexString: string): number => parseInt(hexString, 16);\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? Buffer.from(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport class sha512_256 extends sha512 {\n  constructor() {\n    super();\n    // set the \"SHA-512/256\" initialization vector\n    // see https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\n    Object.assign(this, {\n      _ah: 0x22312194,\n      _al: 0xfc2bf72c,\n      _bh: 0x9f555fa3,\n      _bl: 0xc84c64c2,\n      _ch: 0x2393b86b,\n      _cl: 0x6f53b151,\n      _dh: 0x96387719,\n      _dl: 0x5940eabd,\n      _eh: 0x96283ee2,\n      _el: 0xa88effe3,\n      _fh: 0xbe5e1e25,\n      _fl: 0x53863992,\n      _gh: 0x2b0199fc,\n      _gl: 0x2c85b8aa,\n      _hh: 0x0eb72ddc,\n      _hl: 0x81c52ca2,\n    });\n  }\n  digest(): Buffer;\n  digest(encoding: import('crypto').HexBase64Latin1Encoding): string;\n  digest(encoding?: import('crypto').HexBase64Latin1Encoding): string | Buffer {\n    // \"SHA-512/256\" truncates the digest to 32 bytes\n    const buff = super.digest().slice(0, 32);\n    return encoding ? buff.toString(encoding) : buff;\n  }\n}\n\nexport const txidFromData = (data: Buffer): string => new sha512_256().update(data).digest('hex');\n\nexport const hash160 = (input: Buffer): Buffer => {\n  const sha256Result = new sha256().update(input).digest();\n  return Buffer.from(new RIPEMD160().update(sha256Result).digest());\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Buffer): string => {\n  return hash160(input).toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bufferArray = new BufferArray();\n  // OP_n\n  bufferArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  // OP_m\n  bufferArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bufferArray.appendByte(174);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/** @ignore */\nexport async function fetchPrivate(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const defaultFetchOpts: RequestInit = {\n    referrer: 'no-referrer',\n    referrerPolicy: 'no-referrer',\n  };\n  const fetchOpts = Object.assign(defaultFetchOpts, init);\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  const hexWithoutPrefix = hex.startsWith('0x') ? hex.slice(2) : hex;\n  const bufferCV = Buffer.from(hexWithoutPrefix, 'hex');\n  return deserializeCV(bufferCV);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n","import {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\n\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  compressPublicKey,\n  createStacksPublicKey,\n  deserializePublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignature,\n  serializePublicKey,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { DeserializationError, SerializationError, SigningError } from './errors';\n\nabstract class Deserializable {\n  abstract serialize(): Buffer;\n  abstract deserialize(bufferReader: BufferReader): void;\n  static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T {\n    const message = new this();\n    message.deserialize(bufferReader);\n    return message;\n  }\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = Buffer.from(signature, 'hex').byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n  };\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature {\n  return createMessageSignature(\n    bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex')\n  );\n}\n\nenum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: BigNum;\n  fee: BigNum;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: BigNum;\n  fee: BigNum;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: BigNum,\n  fee: BigNum\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: BigNum,\n  fee: BigNum\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(condition: SpendingCondition): condition is SingleSigSpendingCondition {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingCondition): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = new BigNum(0);\n  cloned.fee = new BigNum(0);\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return cloned;\n}\n\nexport function serializeSingleSigSpendingCondition(condition: SingleSigSpendingCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));\n  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeMultiSigSpendingCondition(condition: MultiSigSpendingCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));\n  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));\n\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bufferReader: BufferReader\n): SingleSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n  const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bufferReader: BufferReader\n): MultiSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n  const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  const signaturesRequired = bufferReader.readUInt16BE();\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingCondition): Buffer {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\n\nexport function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    Buffer.from([authType]).toString('hex') +\n    fee.toArrayLike(Buffer, 'be', 8).toString('hex') +\n    nonce.toArrayLike(Buffer, 'be', 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  if (Buffer.from(sigHash, 'hex').byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const publicKeyEncoding = isCompressed(publicKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKeyEncoding, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum,\n  // @ts-ignore\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature));\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, PubKeyEncoding.Compressed, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    new BigNum(0),\n    new BigNum(0)\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition: SpendingCondition, initialSigHash: string, authType: AuthType): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    // TODO: verify multisig\n    return '';\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingCondition,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // TODO: verify pub key\n\n  return nextSigHash;\n}\n\nexport class Authorization extends Deserializable {\n  authType?: AuthType;\n  spendingCondition?: SpendingCondition;\n  sponsorSpendingCondition?: SpendingCondition;\n\n  constructor(\n    authType?: AuthType,\n    spendingConditions?: SpendingCondition,\n    sponsorSpendingCondition?: SpendingCondition\n  ) {\n    super();\n    this.authType = authType;\n    this.spendingCondition = spendingConditions;\n    this.sponsorSpendingCondition = sponsorSpendingCondition;\n  }\n\n  intoInitialSighashAuth(): Authorization {\n    if (this.spendingCondition) {\n      switch (this.authType) {\n        case AuthType.Standard:\n          return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n        case AuthType.Sponsored:\n          return new Authorization(\n            AuthType.Sponsored,\n            clearCondition(this.spendingCondition),\n            newInitialSigHash()\n          );\n        default:\n          throw new SigningError('Unexpected authorization type for signing');\n      }\n    }\n\n    throw new Error('Authorization missing SpendingCondition');\n  }\n\n  setFee(amount: BigNum) {\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition!.fee = amount;\n        break;\n      case AuthType.Sponsored:\n        this.sponsorSpendingCondition!.fee = amount;\n        break;\n    }\n  }\n\n  getFee() {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return this.spendingCondition!.fee;\n      case AuthType.Sponsored:\n        return this.sponsorSpendingCondition!.fee;\n      default:\n        return 0;\n    }\n  }\n\n  setNonce(nonce: BigNum) {\n    this.spendingCondition!.nonce = nonce;\n  }\n\n  setSponsorNonce(nonce: BigNum) {\n    this.sponsorSpendingCondition!.nonce = nonce;\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingCondition) {\n    this.sponsorSpendingCondition = sponsorSpendingCondition;\n  }\n\n  verifyOrigin(initialSigHash: string): string {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return verify(this.spendingCondition!, initialSigHash, AuthType.Standard);\n      case AuthType.Sponsored:\n        return verify(this.spendingCondition!, initialSigHash, AuthType.Standard);\n      default:\n        throw new SigningError('Invalid origin auth type');\n    }\n  }\n\n  serialize(): Buffer {\n    const bufferArray: BufferArray = new BufferArray();\n    if (this.authType === undefined) {\n      throw new SerializationError('\"authType\" is undefined');\n    }\n    bufferArray.appendByte(this.authType);\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        break;\n      case AuthType.Sponsored:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        if (this.sponsorSpendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n        break;\n      default:\n        throw new SerializationError(\n          `Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`\n        );\n    }\n\n    return bufferArray.concatBuffer();\n  }\n\n  deserialize(bufferReader: BufferReader) {\n    this.authType = bufferReader.readUInt8Enum(AuthType, n => {\n      throw new DeserializationError(`Could not parse ${n} as AuthType`);\n    });\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n      case AuthType.Sponsored:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n      // throw new DeserializationError('Not yet implemented: deserializing sponsored transactions');\n      default:\n        throw new DeserializationError(\n          `Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`\n        );\n    }\n  }\n}\n\nexport class StandardAuthorization extends Authorization {\n  constructor(spendingCondition: SpendingCondition) {\n    super(AuthType.Standard, spendingCondition);\n  }\n}\n\nexport class SponsoredAuthorization extends Authorization {\n  constructor(\n    originSpendingCondition: SpendingCondition,\n    sponsorSpendingCondition?: SpendingCondition\n  ) {\n    let sponsorSC = sponsorSpendingCondition;\n    if (!sponsorSC) {\n      sponsorSC = createSingleSigSpendingCondition(\n        AddressHashMode.SerializeP2PKH,\n        '0'.repeat(66),\n        new BigNum(0),\n        new BigNum(0)\n      );\n    }\n    super(AuthType.Sponsored, originSpendingCondition, sponsorSC);\n  }\n}\n","import { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length === cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n","import {\n  AnchorMode,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  createMessageSignature,\n  createTransactionAuthField,\n  isSingleSig,\n  nextSignature,\n  SingleSigSpendingCondition,\n  SpendingCondition,\n} from './authorization';\n\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BufferReader } from './bufferReader';\n\nimport BigNum from 'bn.js';\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: Payload,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    this.payload = payload;\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  createTxWithSignature(signature: string | Buffer): StacksTransaction {\n    const parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n    const tx = cloneDeep(this);\n    if (!tx.auth.spendingCondition) {\n      throw new Error('Cannot set signature on transaction without spending condition');\n    }\n    (tx.auth.spendingCondition as SingleSigSpendingCondition).signature = createMessageSignature(\n      parsedSig\n    );\n    return tx;\n  }\n\n  verifyOrigin(): string {\n    return this.auth.verifyOrigin(this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.sponsorSpendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(\n      this.auth.sponsorSpendingCondition,\n      sigHash,\n      AuthType.Sponsored,\n      privateKey\n    );\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingCondition,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth.setSponsor(sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param {BigNum} fee - the fee amount in microstacks\n   */\n  setFee(amount: BigNum) {\n    this.auth.setFee(amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param {BigNum} nonce - the nonce value\n   */\n  setNonce(nonce: BigNum) {\n    this.auth.setNonce(nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param {BigNum} nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: BigNum) {\n    this.auth.setSponsorNonce(nonce);\n  }\n\n  serialize(): Buffer {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray: BufferArray = new BufferArray();\n\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(this.auth.serialize());\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n\n    return bufferArray.concatBuffer();\n  }\n}\n\n/**\n * @param data Buffer or hex string\n */\nexport function deserializeTransaction(data: BufferReader | Buffer | string) {\n  let bufferReader: BufferReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = Authorization.deserialize(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig } from './authorization';\nimport { cloneDeep } from './utils';\nimport { SpendingCondition } from './authorization';\nimport { AuthType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n  }\n\n  static createSponsorSigner(transaction: StacksTransaction, spendingCondition: SpendingCondition) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.sponsorSpendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksNetwork, StacksMainnet, StacksTestnet } from '@stacks/network';\n\nimport {\n  createTokenTransferPayload,\n  createSmartContractPayload,\n  createContractCallPayload,\n} from './payload';\n\nimport {\n  StandardAuthorization,\n  SponsoredAuthorization,\n  createSingleSigSpendingCondition,\n  createMultiSigSpendingCondition,\n} from './authorization';\n\nimport {\n  publicKeyToString,\n  createStacksPrivateKey,\n  getPublicKey,\n  publicKeyToAddress,\n  pubKeyfromPrivKey,\n  publicKeyFromBuffer,\n} from './keys';\n\nimport { TransactionSigner } from './signer';\n\nimport {\n  PostCondition,\n  STXPostCondition,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  createSTXPostCondition,\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n} from './postcondition';\n\nimport {\n  AddressHashMode,\n  AddressVersion,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PostConditionMode,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  TxRejectedReason,\n  SingleSigHashMode,\n} from './constants';\n\nimport { AssetInfo, createLPList, createStandardPrincipal, createContractPrincipal } from './types';\n\nimport { cvToHex, parseReadOnlyResponse, omit } from './utils';\n\nimport { fetchPrivate } from '@stacks/common';\n\nimport BigNum from 'bn.js';\nimport { ClarityValue, PrincipalCV } from './clarity';\nimport { validateContractCall, ClarityAbi } from './contract-abi';\nimport { c32address } from 'c32check';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(address: string, network?: StacksNetwork): Promise<BigNum> {\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getAccountApiUrl(address)\n    : defaultNetwork.getAccountApiUrl(address);\n\n  const response = await fetchPrivate(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const result = (await response.json()) as { nonce: string };\n  return new BigNum(result.nonce);\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\nexport type TxBroadcastResultOk = string;\nexport type TxBroadcastResultRejected = {\n  error: string;\n  reason: TxRejectedReason;\n  reason_data: any;\n  txid: string;\n};\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network: StacksNetwork,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const url = network.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Buffer,\n  url: string,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: rawTx.toString('hex'),\n          attachment: attachment.toString('hex'),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchPrivate(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  try {\n    return JSON.parse(text) as TxBroadcastResult;\n  } catch (e) {\n    return text;\n  }\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const url = network.getAbiApiUrl(address, contractName);\n\n  const response = await fetchPrivate(url, options);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n *\n * @param  {String|PrincipalCV} recipientAddress - the c32check address of the recipient or a\n *                                                  principal clarity value\n * @param  {BigNum} amount - number of tokens to transfer in microstacks\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {String} memo - an arbitrary string to include with the transaction, must be less than\n *                          34 bytes\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface TokenTransferOptions {\n  recipient: string | PrincipalCV;\n  amount: BigNum;\n  fee?: BigNum;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  memo?: string;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promis<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization = null;\n  let spendingCondition = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    defaultOptions.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateTransfer(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n *\n * @param  {String} contractName - the contract name\n * @param  {String} codeBody - the code body string\n * @param  {String} senderKey - hex string sender private key used to sign transaction\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface ContractDeployOptions {\n  contractName: string;\n  codeBody: string;\n  senderKey: string;\n  fee?: BigNum;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  sponsored?: boolean;\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const privKey = createStacksPrivateKey(options.senderKey);\n  const pubKey = getPublicKey(privKey);\n\n  let authorization = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateContractDeploy(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  if (options.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {String} senderKey - hex string sender private key used to sign transaction\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface ContractCallOptions {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  fee?: BigNum;\n  feeEstimateApiUrl?: string;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  validateWithAbi?: boolean | ClarityAbi;\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition = null;\n  let authorization = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateContractFunctionCall(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param  {String} address - the c32check address of the contract\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of fungible tokens\n * @param  {AssetInfo} assetInfo - asset info describing the fungible token\n *\n * @return {FungiblePostCondition}\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of fungible tokens\n * @param  {AssetInfo} assetInfo - asset info describing the fungible token\n *\n * @return {FungiblePostCondition}\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Read only function options\n *\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  network?: StacksNetwork;\n  senderAddress: string;\n}\n\n/**\n * Calls a read only function from a contract interface\n *\n * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    network,\n    senderAddress,\n  } = options;\n\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await fetchPrivate(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\n/**\n * Sponsored transaction options\n *\n * @param  {StacksTransaction} transaction - the origin-signed transaction to sponsor\n * @param  {String} sponsorPrivateKey - the sponsor's private key\n * @param  {BigNum} fee - the transaction fee amount to sponsor\n * @param  {BigNum} sponsorNonce - the nonce of the sponsor account\n * @param  {AddressHashMode} sponsorAddressHashmode - the sponsor address hashmode\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n */\nexport interface SponsorOptions {\n  transaction: StacksTransaction;\n  sponsorPrivateKey: string;\n  fee?: BigNum;\n  sponsorNonce?: BigNum;\n  sponsorAddressHashmode?: AddressHashMode;\n  network?: StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param  {SponsorOptions} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    sponsorNonce: new BigNum(0),\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network =\n    sponsorOptions.network ??\n    (options.transaction.version === TransactionVersion.Mainnet\n      ? new StacksMainnet()\n      : new StacksTestnet());\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (!sponsorOptions.fee) {\n    let txFee = new BigNum(0);\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n        txFee = await estimateTransfer(options.transaction, network);\n        break;\n      case PayloadType.SmartContract:\n        txFee = await estimateContractDeploy(options.transaction, network);\n        break;\n      case PayloadType.ContractCall:\n        txFee = await estimateContractFunctionCall(options.transaction, network);\n        break;\n      default:\n        throw new Error(\n          `Spnsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (!sponsorOptions.sponsorNonce) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return options.transaction;\n}\n"],"names":["ChainID","StacksMessageType","PayloadType","AnchorMode","TransactionVersion","DEFAULT_CHAIN_ID","Mainnet","PostConditionMode","PostConditionType","AuthType","AddressHashMode","AddressVersion","PubKeyEncoding","FungibleConditionCode","NonFungibleConditionCode","PostConditionPrincipalID","AssetType","TxRejectedReason","DEFAULT_TRANSACTION_VERSION","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","getAddressFromPublicKey","publicKey","transactionVersion","addressToString","addressFromVersionHash","addressHashModeToVersion","SerializeP2PKH","hashP2PKH","Buffer","from","createStacksPublicKey","PublicKey","data","publicKeyFromSignature","message","messageSignature","ec","EC","messageBN","keyFromPrivate","getPrivate","parsedSignature","parseRecoverableSignature","recoverPubKey","recoveryParam","encodeCompressed","publicKeyFromBuffer","isCompressed","startsWith","publicKeyToString","serializePublicKey","bufferArray","BufferArray","concatBuffer","pubKeyfromPrivKey","privateKey","privKey","createStacksPrivateKey","getPublic","compressed","compressPublicKey","keyFromPublic","deserializePublicKey","bufferReader","fieldId","readUInt8","keyLength","concat","readBuffer","signWithKey","input","signature","sign","canonical","r","leftPadHexToLength","coordinateValueBytes","s","createMessageSignature","intToHexString","recoveryParamHex","substr","hexStringToInt","getPublicKey","publicKeyToAddress","version","c32address","hash160","ClarityType","SerializationError","_this2","captureStackTrace","DeserializationError","_this3","NotImplementedError","_this4","SigningError","_this5","createSTXPostCondition","principal","conditionCode","amount","parsePrincipalString","PostCondition","conditionType","STX","createFungiblePostCondition","assetInfo","parseAssetInfoString","Fungible","createNonFungiblePostCondition","assetName","NonFungible","serializePostCondition","postCondition","appendByte","serializePrincipal","serializeAssetInfo","serializeCV","toArrayLike","deserializePostCondition","postConditionType","readUInt8Enum","n","deserializePrincipal","BigNum","deserializeAssetInfo","deserializeCV","createTokenTransferPayload","recipient","memo","includes","split","contractPrincipalCV","standardPrincipalCV","principalCV","createMemoString","Payload","payloadType","TokenTransfer","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","createAddress","createLPString","ContractCall","createSmartContractPayload","codeBody","codeBodyString","SmartContract","serializePayload","payload","serializeStacksMessage","numArgs","alloc","writeUInt32BE","PoisonMicroblock","Coinbase","coinbaseBuffer","deserializePayload","deserializeMemoString","deserializeAddress","contractCallName","deserializeLPString","numberOfArgs","readUInt32BE","clarityValue","byteLength","createCoinbasePayload","Address","serializeAddress","Principal","LengthPrefixedString","serializeLPString","MemoString","serializeMemoString","AssetInfo","LengthPrefixedList","serializeLPList","TransactionAuthField","serializeTransactionAuthField","MessageSignature","serializeMessageSignature","c32AddressString","addressData","c32addressDecode","createEmptyAddress","MainnetSingleSig","repeat","hash","hashMode","txVersion","Testnet","TestnetSingleSig","JSON","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromPublicKeys","numSigs","publicKeys","hashP2SH","map","address","appendHexString","principalString","createContractPrincipal","createStandardPrincipal","addressString","addr","prefix","Standard","Contract","_","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","exceedsMaxLengthBytes","lps","contentBuffer","prefixBytes","memoString","paddedContent","rightPadHexToLength","MEMO_MAX_LENGTH_BYTES","id","createAssetInfo","createLPList","lpList","list","index","deserializeLPList","l","deserializeTransactionAuthField","principalToString","PrincipalStandard","PrincipalContract","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","cvToValue","val","BoolTrue","BoolFalse","Int","fromTwos","toNumber","UInt","buffer","OptionalNone","OptionalSome","ResponseErr","ResponseOk","cvToJSON","List","v","Tuple","StringASCII","StringUTF8","getCVTypeString","success","join","trueCV","falseCV","intCV","twos","toTwos","bitLength","uintCV","isNeg","bufferCV","bufferCVFromString","str","noneCV","someCV","responseErrorCV","responseOkCV","listCV","tupleCV","isClarityName","stringAsciiCV","stringUtf8CV","bufferWithTypeID","typeId","serializeStringCV","cv","encoding","buffers","len","serializeBoolCV","serializeBufferCV","serializeIntCV","serializeStandardPrincipalCV","serializeContractPrincipalCV","serializeResponseCV","serializedValue","serializeListCV","sort","a","b","bufA","bufB","compare","nameWithLength","serializeTupleCV","serializeStringAsciiCV","serializeStringUtf8CV","enumCheckFunctions","Map","BufferReader","options","smartBuffer","isBuffer","SmartBuffer","buff","fromBuffer","offset","readUInt16BE","readBigUIntLE","hex","BigInt","readBigUIntBE","readBigUInt64BE","readString","enumVariable","invalidEnumErrorFormatter","num","isEnum","checker","get","newChecker","enumValues","filter","enumValueSet","Set","has","createEnumChecker","set","readOffset","internalBuffer","bufferLength","listLength","listContents","tupleLength","tupleContents","clarityName","asciiStrLen","asciiStr","utf8StrLen","utf8Str","hexString","_value","octet","Number","isInteger","leftPadHex","padStart","padEnd","integer","lengthBytes","parseInt","string","cloneDeep","lodashCloneDeep","omit","prop","clone","sha512_256","assign","_ah","_al","_bh","_bl","_ch","_cl","_dh","_dl","_eh","_el","_fh","_fl","_gh","_gl","_hh","_hl","digest","_sha","sha512","txidFromData","update","sha256Result","sha256","RIPEMD160","pubKeys","pubKey","redeemScript","test","init","fetchOpts","referrer","referrerPolicy","fetch","cvToHex","hexToCV","hexWithoutPrefix","AuthFieldType","parseReadOnlyResponse","response","okay","cause","Deserializable","deserialize","emptyMessageSignature","deserializeMessageSignature","createTransactionAuthField","pubKeyEncoding","contents","field","Compressed","PublicKeyCompressed","PublicKeyUncompressed","SignatureCompressed","SignatureUncompressed","authFieldType","Uncompressed","createSingleSigSpendingCondition","nonce","fee","signer","keyEncoding","createMultiSigSpendingCondition","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","serializeSingleSigSpendingCondition","serializeMultiSigSpendingCondition","writeUInt16BE","deserializeSingleSigSpendingCondition","deserializeMultiSigSpendingCondition","serializeSpendingCondition","deserializeSpendingCondition","makeSigHashPreSign","curSigHash","authType","sigHash","makeSigHashPostSign","nextSignature","sigHashPreSign","nextSig","nextSigHash","nextVerification","initialSigHash","ClarityAbiTypeId","Authorization","spendingConditions","sponsorSpendingCondition","spendingCondition","intoInitialSighashAuth","Sponsored","setFee","getFee","setNonce","setSponsorNonce","setSponsor","verifyOrigin","verifySingleSig","verify","serialize","StandardAuthorization","_Authorization","SponsoredAuthorization","originSpendingCondition","sponsorSC","_Authorization2","StacksTransaction","auth","postConditions","postConditionMode","anchorMode","chainId","Deny","OnChainOnly","Any","signBegin","tx","txid","verifyBegin","createTxWithSignature","parsedSig","signNextOrigin","signAndAppend","signNextSponsor","appendPubkey","cond","endsWith","serialized","chainIdBuffer","TransactionSigner","transaction","originDone","checkOversign","checkOverlap","createSponsorSigner","originSigHash","signOrigin","nextSighash","appendOrigin","signSponsor","getTxInComplete","resume","isClarityAbiPrimitive","isClarityAbiBuffer","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","getTypeUnion","ClarityAbiTypeUInt128","ClarityAbiTypeInt128","ClarityAbiTypeBool","ClarityAbiTypePrincipal","ClarityAbiTypeTraitReference","ClarityAbiTypeNone","ClarityAbiTypeBuffer","ClarityAbiTypeResponse","ClarityAbiTypeOptional","ClarityAbiTypeTuple","ClarityAbiTypeList","ClarityAbiTypeStringAscii","ClarityAbiTypeStringUtf8","getTypeString","ok","t","matchType","abiType","union","every","abiTupleEntry","validateContractCall","abi","filtered","functions","abiArgs","args","payloadArg","abiArg","getNonce","network","defaultNetwork","StacksMainnet","url","getAccountApiUrl","fetchPrivate","msg","text","status","statusText","json","estimateTransfer","fetchOptions","headers","Accept","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","feeRate","mul","attachment","rawTx","getBroadcastApiUrl","broadcastRawTransaction","body","_context4","parse","getAbi","getAbiApiUrl","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","sponsored","numSignatures","authorization","lpPostConditions","addressVersion","senderAddress","senderKey","pk","signerKeys","estimateContractDeploy","addressHashMode","estimateContractFunctionCall","makeUnsignedContractCall","validateWithAbi","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","sender","arguments","responseJson","sponsorOptions","sponsorNonce","sponsorAddressHashmode","StacksTestnet","sponsorPubKey","sponsorPrivateKey","txFee","func","access","sp","lengthPrefixedContractName","cvToString","listType","toLowerCase","entropy","randomBytes","genKeyPair","typeString","stacksAddress","e"],"mappings":"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"}